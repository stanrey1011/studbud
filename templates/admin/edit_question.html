{% extends 'base.html' %}
{% block content %}
<div class="card">
  <div class="card-body">
    <h2 class="card-title">Edit Question ID: {{ question.id }}</h2>
    <form method="POST" enctype="multipart/form-data" style="max-width: 100%; width: 600px;" id="questionForm">
      {{ form.hidden_tag() }}
      <div class="mb-3">
        {{ form.type.label(class="form-label") }}
        {{ form.type(class="form-select", id="questionType") }}
        {% for error in form.type.errors %}
          <span class="text-danger">{{ error }}</span>
        {% endfor %}
      </div>
      <div class="mb-3">
        {{ form.text.label(class="form-label") }}
        {{ form.text(class="form-control") }}
        {% for error in form.text.errors %}
          <span class="text-danger">{{ error }}</span>
        {% endfor %}
      </div>
      <div class="mb-3" id="optionsContainer">
        {{ form.options.label(class="form-label") }}
        {{ form.options(class="form-control", id="optionsInput") }}
        <small class="form-text" id="optionsHelp">
          For MCQ/MRQ/TF: Use option builder below or enter JSON array manually. For Flashcard: JSON object, e.g., {"back": "Answer"}. For Match: Use fields below to add terms and definitions (up to 8 pairs).
        </small>
        
        <!-- MCQ/MRQ Option Builder -->
        <div id="mcqFields" style="display: {% if form.type.data in ['mcq', 'mrq', 'tf'] %}block{% else %}none{% endif %};">
          <div id="optionList">
            {% if form.type.data in ['mcq', 'mrq', 'tf'] and parsed_options %}
              {% for option in parsed_options %}
                <div class="option-item mb-3">
                  <div class="d-flex gap-2 align-items-start flex-wrap">
                    <div class="flex-grow-1">
                      <textarea class="form-control option-text" rows="3" placeholder="Enter option text (multi-line supported for configurations)" required>{{ option }}</textarea>
                    </div>
                    <button type="button" class="btn btn-danger btn-sm remove-option">Remove</button>
                  </div>
                </div>
              {% endfor %}
            {% endif %}
          </div>
          <div class="d-flex gap-2 mt-2">
            <button type="button" class="btn btn-secondary" id="addOption">Add Option</button>
            <button type="button" class="btn btn-info btn-sm" id="toggleJsonView">Toggle JSON View</button>
          </div>
        </div>
        
        <div id="matchFields" style="display: {% if form.type.data == 'match' %}block{% else %}none{% endif %};">
          <div id="termDefinitionPairs">
            {% if form.type.data == 'match' and parsed_terms %}
              {% for term in parsed_terms %}
                {% set def_id = parsed_mappings.get(term.id|string, '') %}
                {% set def = (parsed_definitions | selectattr('id', 'equalto', def_id) | first if def_id else None) %}
                <div class="term-definition-pair mb-3">
                  <div class="d-flex gap-2 align-items-center flex-wrap">
                    <input type="text" class="form-control term-input" placeholder="Term (e.g., KEK)" data-id="{{ term.id }}" value="{{ term.text|default('') }}" required>
                    <input type="text" class="form-control definition-input" placeholder="Definition (e.g., Key Encryption Key)" data-id="{{ term.id }}" value="{{ def.text|default('') if def else '' }}" required>
                    <button type="button" class="btn btn-danger btn-sm remove-pair">Remove</button>
                  </div>
                </div>
              {% endfor %}
            {% endif %}
          </div>
          <button type="button" class="btn btn-secondary mt-2" id="addPair">Add Term-Definition Pair</button>
        </div>
      </div>
      <div class="mb-3">
        {{ form.correct.label(class="form-label") }}
        <div id="correctField">
          {% if form.type.data == 'mrq' %}
            {% if form.correct.choices %}
              <div class="form-group" style="max-width: 100%; display: flex; flex-wrap: wrap; gap: 10px; align-items: flex-start;">
                {% for value, label in form.correct.choices %}
                  <div class="form-check" style="flex: 1 1 200px; min-width: 0;">
                    <input type="checkbox" name="correct" value="{{ value }}"
                           {% if value in (form.correct.data or []) %}checked{% endif %} class="form-check-input">
                    <label class="form-check-label">{{ label }}</label>
                  </div>
                {% endfor %}
              </div>
            {% else %}
              <p class="text-danger">No valid options defined for MRQ. Add options first.</p>
            {% endif %}
          {% elif form.type.data == 'match' %}
            {{ form.match_mappings(class="form-control", id="matchMappingsInput", style="display: none;") }}
            <small class="form-text">Mappings are generated from term-definition pairs above.</small>
          {% else %}
            <select name="correct" class="form-control" style="width: 100%;">
              <option value="">Select</option>
              {% for value, label in form.correct.choices %}
                <option value="{{ value }}" {% if value in (form.correct.data or []) %}selected{% endif %}>{{ label }}</option>
              {% endfor %}
            </select>
          {% endif %}
          {% for error in form.correct.errors %}
            <span class="text-danger">{{ error }}</span>
          {% endfor %}
        </div>
      </div>
      <div class="mb-3">
        {{ form.explanation.label(class="form-label") }}
        {{ form.explanation(class="form-control") }}
        {% for error in form.explanation.errors %}
          <span class="text-danger">{{ error }}</span>
        {% endfor %}
      </div>
      <div class="mb-3">
        {{ form.image.label(class="form-label") }}
        {{ form.image(class="form-control", id="imageInput") }}
        <small class="form-text">Upload topology screenshot (PNG/JPG).</small>
        <div id="preview" style="display:none;"><img id="previewImg" alt="Preview" style="max-width: 200px; margin-top: 10px;"></div>
        {% if question.image %}
          <img src="{{ url_for('serve_image', filename=question.image) }}" alt="Current Topology" class="img-thumbnail" style="max-width: 200px; margin-top: 10px;">
        {% endif %}
        {% if form.delete_image %}
          <div class="form-check mt-2">
            {{ form.delete_image(class="form-check-input") }}
            {{ form.delete_image.label(class="form-check-label") }}
          </div>
        {% endif %}
      </div>
      {{ form.submit(class="btn btn-primary") }}
    </form>
  </div>
</div>
{% endblock %}
{% block scripts %}
<script>
document.getElementById('imageInput').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      document.getElementById('previewImg').src = e.target.result;
      document.getElementById('preview').style.display = 'block';
    };
    reader.readAsDataURL(file);
  }
});

document.getElementById('questionType').addEventListener('change', function(e) {
  const type = e.target.value;
  const matchFields = document.getElementById('matchFields');
  const mcqFields = document.getElementById('mcqFields');
  
  if (type === 'match') {
    matchFields.style.display = 'block';
    mcqFields.style.display = 'none';
  } else if (['mcq', 'mrq', 'tf'].includes(type)) {
    matchFields.style.display = 'none';
    mcqFields.style.display = 'block';
  } else {
    matchFields.style.display = 'none';
    mcqFields.style.display = 'none';
  }
});

document.getElementById('addPair')?.addEventListener('click', function() {
  const pairs = document.querySelectorAll('.term-definition-pair').length;
  if (pairs >= 8) {
    alert('Maximum of 8 term-definition pairs allowed.');
    return;
  }
  
  // Use a temporary ID that will be reassigned in updateMatchJson()
  const tempId = 'temp_' + Date.now();
  const pairDiv = document.createElement('div');
  pairDiv.className = 'term-definition-pair mb-3';
  pairDiv.innerHTML = `
    <div class="d-flex gap-2 align-items-center">
      <input type="text" class="form-control term-input" placeholder="Term (e.g., KEK)" data-id="${tempId}" required>
      <input type="text" class="form-control definition-input" placeholder="Definition (e.g., Key Encryption Key)" data-id="${tempId}" required>
      <button type="button" class="btn btn-danger btn-sm remove-pair">Remove</button>
    </div>
  `;
  document.getElementById('termDefinitionPairs').appendChild(pairDiv);
  
  // Immediately trigger update to assign proper sequential IDs
  updateMatchJson();
});

document.getElementById('termDefinitionPairs')?.addEventListener('click', function(e) {
  if (e.target.classList.contains('remove-pair')) {
    e.target.closest('.term-definition-pair').remove();
    updateMatchJson();
  }
});

document.getElementById('termDefinitionPairs')?.addEventListener('input', updateMatchJson);

function updateMatchJson() {
  const terms = [];
  const definitions = [];
  const mappings = {};
  let currentId = 1;
  
  document.querySelectorAll('.term-definition-pair').forEach(pair => {
    const termInput = pair.querySelector('.term-input');
    const definitionInput = pair.querySelector('.definition-input');
    
    if (termInput.value.trim() && definitionInput.value.trim()) {
      // Use sequential IDs starting from 1
      const id = currentId.toString();
      terms.push({ id: id, text: termInput.value.trim() });
      definitions.push({ id: id, text: definitionInput.value.trim() });
      mappings[id] = id;
      
      // Update the data-id attributes to reflect new IDs
      termInput.dataset.id = id;
      definitionInput.dataset.id = id;
      
      currentId++;
    }
  });
  
  document.getElementById('optionsInput').value = JSON.stringify({ terms, definitions }, null, 2);
  document.getElementById('matchMappingsInput').value = JSON.stringify(mappings, null, 2);
}

document.getElementById('questionForm').addEventListener('submit', function(e) {
  const pairs = document.querySelectorAll('.term-definition-pair');
  if (pairs.length > 8) {
    e.preventDefault();
    alert('Maximum of 8 term-definition pairs allowed.');
    return;
  }
  for (let pair of pairs) {
    const termInput = pair.querySelector('.term-input');
    const definitionInput = pair.querySelector('.definition-input');
    if (!termInput.value.trim() || !definitionInput.value.trim()) {
      e.preventDefault();
      alert('Please fill in all term and definition fields or remove empty pairs.');
      return;
    }
  }
  
  // Ensure JSON is updated before submission
  if (document.getElementById('questionType').value === 'match') {
    updateMatchJson();
  } else if (['mcq', 'mrq', 'tf'].includes(document.getElementById('questionType').value)) {
    updateMcqJson();
  }
});

// MCQ/MRQ Option Builder Functions
document.getElementById('addOption')?.addEventListener('click', function() {
  const optionDiv = document.createElement('div');
  optionDiv.className = 'option-item mb-3';
  optionDiv.innerHTML = `
    <div class="d-flex gap-2 align-items-start">
      <div class="flex-grow-1">
        <textarea class="form-control option-text" rows="3" placeholder="Enter option text (multi-line supported for configurations)" required></textarea>
      </div>
      <button type="button" class="btn btn-danger btn-sm remove-option">Remove</button>
    </div>
  `;
  document.getElementById('optionList').appendChild(optionDiv);
  updateMcqJson();
});

document.getElementById('optionList')?.addEventListener('click', function(e) {
  if (e.target.classList.contains('remove-option')) {
    e.target.closest('.option-item').remove();
    updateMcqJson();
  }
});

document.getElementById('optionList')?.addEventListener('input', function(e) {
  if (e.target.classList.contains('option-text')) {
    updateMcqJson();
  }
});

document.getElementById('toggleJsonView')?.addEventListener('click', function() {
  const optionsInput = document.getElementById('optionsInput');
  if (optionsInput.style.display === 'none') {
    optionsInput.style.display = 'block';
    this.textContent = 'Hide JSON View';
  } else {
    optionsInput.style.display = 'none';
    this.textContent = 'Show JSON View';
  }
});

function updateMcqJson() {
  const options = [];
  document.querySelectorAll('.option-text').forEach(textarea => {
    if (textarea.value.trim()) {
      options.push(textarea.value.trim());
    }
  });
  document.getElementById('optionsInput').value = JSON.stringify(options, null, 2);
}

// Initialize page based on question type
document.addEventListener('DOMContentLoaded', function() {
  const questionType = document.getElementById('questionType').value;
  if (questionType === 'match') {
    updateMatchJson();
  } else if (['mcq', 'mrq', 'tf'].includes(questionType)) {
    updateMcqJson();
    // Hide JSON input by default for MCQ
    document.getElementById('optionsInput').style.display = 'none';
  }
});
</script>
{% endblock %}